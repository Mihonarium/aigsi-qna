<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Live Q&A Session</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
<style>
:root {
--bg-color: #0D1117;
--card-color: #161B22;
--border-color: #30363D;
--text-primary: #C9D1D9;
--text-secondary: #8B949E;
--accent-gradient: linear-gradient(45deg, #A855F7, #D946EF);
--accent-hover: linear-gradient(45deg, #9333EA, #C026D3);
--green: #238636;
--red: #DA3633;
--blue: #1F6FEB;
--orange: #FB8500;
--font-family: 'Inter', sans-serif;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; }

html {
scroll-behavior: smooth;
}

body {
background-color: var(--bg-color);
color: var(--text-primary);
font-family: var(--font-family);
line-height: 1.6;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}

.app-container {
display: grid;
grid-template-columns: 1fr;
gap: 2rem;
max-width: 1200px;
margin: 0 auto;
padding: clamp(1rem, 5vw, 3rem);
}

@media (min-width: 992px) {
.app-container {
    grid-template-columns: 2fr 1fr;
    grid-template-areas: "main aside";
}
.qa-list-container { grid-area: main; }
.side-panel { grid-area: aside; position: sticky; top: 2rem; align-self: start; }
}

body.session-unavailable .app-container {
grid-template-columns: 1fr;
}

body.session-unavailable .qa-list-container,
body.session-unavailable .side-panel,
body.session-unavailable .mobile-ask-btn,
body.session-unavailable .speaker-indicator {
display: none;
}

body.session-unavailable .session-controls {
max-width: 480px;
margin-left: auto;
margin-right: auto;
}

body.session-unavailable .session-info {
justify-content: center;
}

body.session-unavailable .session-info-divider {
display: none;
}

.app-header {
grid-column: 1 / -1;
text-align: center;
margin-bottom: 1rem;
}
.app-header h1 {
font-size: clamp(2rem, 6vw, 3rem);
font-weight: 800;
}
.app-header p {
color: var(--text-secondary);
font-size: clamp(0.9rem, 2vw, 1.1rem);
max-width: 60ch;
margin: 0.5rem auto 0;
}

.session-info {
background: var(--card-color);
border: 1px solid var(--border-color);
padding: 0.5rem 1rem;
border-radius: 99px;
font-size: 0.9rem;
color: var(--text-secondary);
display: inline-flex;
align-items: center;
gap: 0.75rem;
margin-top: 1.5rem;
}
.session-info span { font-weight: 600; color: var(--text-primary); }

.session-info .session-info-divider { color: var(--border-color); }

.session-warning {
background: rgba(218, 54, 51, 0.12);
border: 1px solid rgba(218, 54, 51, 0.5);
color: #ffaba8;
padding: 0.75rem 1rem;
border-radius: 12px;
margin-top: 1rem;
display: none;
font-size: 0.9rem;
line-height: 1.5;
}
.session-warning a { color: #ffaba8; text-decoration: underline; }


.toast-container {
position: fixed;
top: 1.25rem;
right: 1.25rem;
display: flex;
flex-direction: column;
gap: 0.75rem;
z-index: 3000;
max-width: min(320px, calc(100vw - 2.5rem));
}
.toast {
background: rgba(22, 27, 34, 0.94);
border: 1px solid rgba(85, 85, 85, 0.4);
border-radius: 10px;
color: #ffffff;
padding: 0.85rem 1rem;
box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
display: flex;
align-items: flex-start;
gap: 0.75rem;
transform: translateY(-10px);
opacity: 0;
transition: opacity 0.2s ease, transform 0.2s ease;
font-size: 0.9rem;
}
.toast.show {
opacity: 1;
transform: translateY(0);
}
.toast-info { border-color: rgba(31, 111, 235, 0.5); }
.toast-success { border-color: rgba(35, 134, 54, 0.5); }
.toast-warning { border-color: rgba(251, 133, 0, 0.5); }
.toast-error { border-color: rgba(218, 54, 51, 0.6); }
.toast-close {
background: none;
border: none;
color: inherit;
margin-left: auto;
font-size: 1.1rem;
line-height: 1;
cursor: pointer;
padding: 0;
opacity: 0.6;
transition: opacity 0.2s ease;
}
.toast-close:hover { opacity: 1; }

.modal-overlay {
position: fixed;
top: 0;
right: 0;
bottom: 0;
left: 0;
background: rgba(13, 17, 23, 0.85);
display: flex;
align-items: center;
justify-content: center;
z-index: 3500;
padding: 1.5rem;
}
.modal-dialog {
background: var(--card-color);
border: 1px solid var(--border-color);
border-radius: 14px;
padding: 1.5rem;
width: min(420px, 100%);
box-shadow: 0 24px 56px rgba(0, 0, 0, 0.45);
display: flex;
flex-direction: column;
gap: 1rem;
}
.modal-dialog p {
margin: 0;
font-size: 0.95rem;
color: var(--text-primary);
}
.modal-actions {
display: flex;
justify-content: flex-end;
gap: 0.75rem;
}
.modal-actions button {
background: rgba(255, 255, 255, 0.08);
border: 1px solid rgba(255, 255, 255, 0.12);
color: var(--text-primary);
padding: 0.45rem 1rem;
border-radius: 8px;
font-weight: 600;
cursor: pointer;
transition: background 0.2s ease, transform 0.2s ease;
}
.modal-actions button:hover {
background: rgba(255, 255, 255, 0.14);
transform: translateY(-1px);
}
.modal-actions .modal-confirm {
background: var(--accent-gradient);
border: none;
color: #ffffff;
}
.modal-actions .modal-confirm:hover {
transform: translateY(-1px);
box-shadow: 0 12px 24px rgba(168, 85, 247, 0.3);
}
.modal-copy-field {
display: flex;
gap: 0.5rem;
align-items: center;
background: rgba(13, 17, 23, 0.85);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 0.5rem;
}
.modal-copy-field input {
flex: 1;
background: transparent;
border: none;
color: var(--text-primary);
font-size: 0.9rem;
outline: none;
}
.modal-copy-field button {
background: rgba(255, 255, 255, 0.08);
border: 1px solid rgba(255, 255, 255, 0.15);
color: var(--text-primary);
border-radius: 6px;
padding: 0.35rem 0.75rem;
cursor: pointer;
font-weight: 600;
transition: background 0.2s ease;
}
.modal-copy-field button:hover {
background: rgba(255, 255, 255, 0.14);
}


.session-controls {
background: rgba(22, 27, 34, 0.8);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: 1rem;
margin-top: 1rem;
display: flex;
flex-direction: column;
gap: 1rem;
text-align: left;
max-width: 480px;
margin-left: auto;
margin-right: auto;
}
.session-controls h2 {
font-size: 1.1rem;
margin-bottom: 0.25rem;
text-align: center;
}
.session-controls p {
font-size: 0.85rem;
color: var(--text-secondary);
text-align: center;
}
.session-tools-label {
display: block;
text-align: center;
font-weight: 600;
color: var(--text-secondary);
}
body.session-active .session-controls-title,
body.session-active .session-controls-description {
display: none;
}
.session-controls button {
background: var(--accent-gradient);
color: white;
padding: 0.6rem 1rem;
border: none;
border-radius: 8px;
font-weight: 600;
cursor: pointer;
transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.session-controls button:hover:not(:disabled) {
transform: translateY(-1px);
box-shadow: 0 8px 18px rgba(168, 85, 247, 0.35);
}
.session-controls button:disabled {
cursor: wait;
opacity: 0.7;
}
.session-links {
display: none;
flex-direction: column;
gap: 0.75rem;
border-top: 1px solid rgba(48, 54, 61, 0.7);
padding-top: 0.75rem;
}
.session-link-row {
display: flex;
gap: 0.5rem;
align-items: center;
}
.session-link-row label {
min-width: 90px;
font-size: 0.85rem;
color: var(--text-secondary);
}
.session-link-row input {
flex: 1;
background: rgba(13, 17, 23, 0.8);
border: 1px solid var(--border-color);
border-radius: 6px;
padding: 0.5rem;
color: var(--text-primary);
font-size: 0.85rem;
}
.session-link-row button {
background: rgba(168, 85, 247, 0.2);
color: #d8b4fe;
border-radius: 6px;
border: 1px solid rgba(168, 85, 247, 0.6);
padding: 0.45rem 0.75rem;
font-size: 0.8rem;
}
.session-link-row button:hover:not(:disabled) {
transform: none;
box-shadow: none;
background: rgba(168, 85, 247, 0.3);
}
.manual-session {
display: flex;
flex-direction: column;
gap: 0.5rem;
}
.manual-session label {
font-size: 0.85rem;
color: var(--text-secondary);
}
.manual-session-row {
display: flex;
gap: 0.5rem;
}
.manual-session-row input {
flex: 1;
background: rgba(13, 17, 23, 0.8);
border: 1px solid var(--border-color);
border-radius: 6px;
padding: 0.5rem;
color: var(--text-primary);
font-size: 0.9rem;
}
.manual-session-row button {
background: var(--blue);
color: white;
border-radius: 6px;
}
.manual-session-row button:hover:not(:disabled) {
transform: none;
box-shadow: none;
}


/* Speaker Mode Indicator */
.speaker-indicator {
background: var(--green);
color: white;
padding: 0.5rem 1rem;
border-radius: 99px;
font-size: 0.9rem;
font-weight: 600;
display: none;
align-items: center;
gap: 0.5rem;
margin-top: 0.5rem;
}
.speaker-indicator > button {
background: rgba(255, 255, 255, 0.2);
border: 1px solid rgba(255, 255, 255, 0.3);
color: white;
padding: 0.2rem 0.6rem;
border-radius: 99px;
font-size: 0.8rem;
cursor: pointer;
transition: background 0.2s;
margin: 0 0 0 0.25rem;
width: auto;
text-transform: none;
letter-spacing: normal;
font-weight: 500;
}
.speaker-indicator > button:hover {
background: rgba(255, 255, 255, 0.3);
transform: none;
box-shadow: none;
}
body.speaker-view .speaker-indicator {
display: inline-flex;
}

/* Mobile Ask Question Button */
.mobile-ask-btn {
display: none;
background: var(--accent-gradient);
color: white;
padding: 0.75rem 1.5rem;
border: none;
border-radius: 99px;
font-size: 1rem;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease-out;
margin-top: 1rem;
text-decoration: none;
display: inline-block;
box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
}
.mobile-ask-btn:hover { 
transform: translateY(-2px); 
box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4); 
}
@media (max-width: 991px) {
.mobile-ask-btn { display: inline-block; }
}

/* Form styling */
.form-container {
background-color: var(--card-color);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: 1.5rem;
position: relative;
overflow: hidden;
}
.form-container h2 {
font-size: 1.25rem;
font-weight: 700;
margin-bottom: 1rem;
}
.form-group { margin-bottom: 1rem; }
.form-group label {
display: block;
font-size: 0.9rem;
font-weight: 500;
color: var(--text-secondary);
margin-bottom: 0.5rem;
}
.form-group input, .form-group textarea {
width: 100%;
background-color: var(--bg-color);
border: 1px solid var(--border-color);
color: var(--text-primary);
padding: 0.75rem;
border-radius: 8px;
font-size: 1rem;
font-family: inherit;
transition: border-color 0.2s, box-shadow 0.2s;
}
.form-group textarea { resize: vertical; min-height: 80px; }
.form-group input:focus, .form-group textarea:focus {
outline: none;
border-color: var(--blue);
box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.3);
}
.form-container.disabled form {
pointer-events: none;
opacity: 0.35;
filter: saturate(0.6);
}
.form-container.disabled::after {
content: 'Create or join a session to ask questions';
position: absolute;
top: 1.5rem;
left: 1.5rem;
right: 1.5rem;
bottom: 1.5rem;
display: flex;
align-items: center;
justify-content: center;
text-align: center;
background: rgba(13, 17, 23, 0.92);
border: 1px dashed rgba(201, 209, 217, 0.3);
border-radius: 10px;
font-size: 0.95rem;
color: var(--text-secondary);
padding: 1rem;
}
.submit-btn {
width: 100%;
background: var(--accent-gradient);
color: white;
padding: 0.8rem 1.5rem;
border: none;
border-radius: 8px;
font-size: 1rem;
font-weight: 700;
cursor: pointer;
transition: all 0.2s ease-out;
}
.submit-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2); }
.submit-btn:disabled { background: var(--border-color); color: var(--text-secondary); cursor: not-allowed; transform: none; box-shadow: none; }

/* Q&A List */
.qa-list { display: flex; flex-direction: column; gap: 1rem; }

.qa-card {
background-color: var(--card-color);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: 1.5rem;
display: flex;
gap: 1.25rem;
transition: opacity 0.4s ease, transform 0.4s ease, background-color 0.4s;
position: relative;
}
.qa-card.new-card {
opacity: 0;
transform: translateY(20px);
}
.qa-card.answered-by-speaker { opacity: 0.6; }
.qa-card.hidden {
opacity: 0.5;
background-color: rgba(139, 148, 158, 0.1);
}

.vote-section { flex-shrink: 0; text-align: center; }
.vote-btn {
background: none;
border: 1px solid var(--border-color);
color: var(--text-secondary);
width: 40px; height: 30px;
border-radius: 6px;
font-size: 1.1rem;
cursor: pointer;
transition: all 0.2s;
}
.vote-btn:hover:not(.voted) { background-color: #ffffff1a; color: var(--text-primary); }
.vote-btn.voted {
background-color: var(--blue);
color: white;
border-color: var(--blue);
cursor: not-allowed;
}
.vote-count {
font-size: 1.25rem;
font-weight: 700;
display: block;
margin: 0.25rem 0;
transition: transform 0.2s;
}

.content-section { flex-grow: 1; min-width: 0; }

.question-header {
display: flex;
flex-wrap: wrap;
gap: 0.5rem 1rem;
align-items: center;
margin-bottom: 0.5rem;
}
.author-name { font-weight: 600; color: var(--text-primary); }
.timestamp { font-size: 0.85rem; color: var(--text-secondary); }
.status-badge {
font-size: 0.75rem;
font-weight: 600;
padding: 0.2rem 0.6rem;
border-radius: 99px;
text-transform: uppercase;
}
.status-badge.new, .status-badge.ai_answering { background-color: #8B949E20; color: #8B949E; }
.status-badge.ai_answering { animation: pulse 1.5s infinite; }
.status-badge.ai_answered { background-color: #A855F720; color: #C084FC; }
.status-badge.speaker_answered { background-color: #23863620; color: #3FB950; }
.status-badge.hidden { background-color: #DA363320; color: #F85149; }
@keyframes pulse { 50% { opacity: 0.6; } }

.question-text { margin-bottom: 1.5rem; font-size: 1.1rem; word-wrap: break-word; }

.ai-answer-container {
border-top: 1px solid var(--border-color);
margin-top: 1rem;
padding-top: 1rem;
}
.ai-answer-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
.ai-title { font-weight: 600; font-size: 0.9rem; background: var(--accent-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.ai-title.marked-correct { color: var(--green); background: none; -webkit-text-fill-color: var(--green); }
.ai-title.marked-correct::after { content: " ✓"; }
.ai-vote-controls { display: flex; align-items: center; gap: 0.5rem; }
.ai-vote-btn { background: none; border: none; font-size: 1.1rem; cursor: pointer; transition: transform 0.2s; }
.ai-vote-btn:hover:not(.voted) { transform: scale(1.2); }
.ai-vote-count { font-size: 0.9rem; color: var(--text-secondary); min-width: 15px; text-align: center; }

.ai-answer-text { color: var(--text-secondary); font-size: 0.95rem; }
.ai-answer-text a,
.ai-answer-text a:visited { color: #ffffff; text-decoration: underline; }
.ai-answer-text a:hover { color: #d8b4fe; }
.ai-answer-text p:last-child { margin-bottom: 0; }
.ai-answer-text code { background: #ffffff1a; padding: 0.2em 0.4em; border-radius: 4px; font-size: 0.9em; }

.speaker-actions { margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap; }
.speaker-btn {
flex: 1;
min-width: 140px;
background-color: var(--green);
color: white;
font-weight: 600;
font-size: 0.85rem;
border: none;
padding: 0.5rem 0.75rem;
border-radius: 8px;
cursor: pointer;
transition: background-color 0.2s;
}
.speaker-btn:hover { background-color: #2ea043; }
.speaker-btn.danger { background-color: var(--red); }
.speaker-btn.danger:hover { background-color: #b91c1c; }
.speaker-btn.secondary { background-color: var(--orange); }
.speaker-btn.secondary:hover { background-color: #ea580c; }

.empty-state, .loading-state {
text-align: center;
padding: 4rem 2rem;
color: var(--text-secondary);
}

/* QR Code Modal */
.qr-modal {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.9);
z-index: 1000;
justify-content: center;
align-items: center;
cursor: pointer;
}
.qr-modal.show {
display: flex;
}
.qr-modal-content {
background: white;
padding: 2rem;
border-radius: 16px;
text-align: center;
cursor: default;
max-width: 90%;
max-height: 90vh;
overflow: auto;
}
.qr-modal-content h2 {
color: var(--bg-color);
margin-bottom: 1rem;
font-size: 1.5rem;
}
.qr-modal-content p {
color: var(--border-color);
margin-bottom: 1.5rem;
font-size: 0.9rem;
}
#qrcode {
display: inline-block;
padding: 1rem;
background: white;
border-radius: 8px;
margin-bottom: 1rem;
}
.qr-url {
background: #f5f5f5;
padding: 0.75rem;
border-radius: 8px;
font-family: monospace;
font-size: 0.85rem;
color: var(--bg-color);
word-break: break-all;
margin-bottom: 1rem;
}
.close-qr {
background: var(--accent-gradient);
color: white;
border: none;
padding: 0.75rem 2rem;
border-radius: 8px;
font-size: 1rem;
font-weight: 600;
cursor: pointer;
transition: all 0.2s;
}
.close-qr:hover {
transform: translateY(-2px);
box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
}
.qr-button {
background: rgba(255, 255, 255, 0.1);
border: 1px solid rgba(255, 255, 255, 0.2);
color: var(--text-primary);
padding: 0.4rem 0.8rem;
border-radius: 99px;
font-size: 0.85rem;
font-weight: 500;
cursor: pointer;
transition: all 0.2s;
display: inline-flex;
align-items: center;
gap: 0.4rem;
margin: -0.2rem 0 -0.2rem 0.5rem;
}
.qr-button:hover {
background: rgba(255, 255, 255, 0.15);
border-color: rgba(255, 255, 255, 0.3);
transform: translateY(-1px);
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

@media (max-width: 768px) {
.qr-modal-content {
    padding: 1.5rem;
}
.qr-modal-content h2 {
    font-size: 1.25rem;
}
#qrcode {
    transform: scale(0.8);
    margin: -1rem 0;
}
}
</style>
</head>
<body class="session-unavailable">

<div id="toast-container" class="toast-container" aria-live="polite" aria-atomic="true"></div>

<div class="app-container" id="app">
<header class="app-header">
<h1>Live Q&A</h1>
<p>Ask your questions to the speaker. The most upvoted questions rise to the top. An AI assistant will provide initial answers.</p>
<div class="session-info" id="session-info">
    <span>Session ID: <span id="session-id-display"></span></span>
    <span class="session-info-divider">|</span>
    <button class="qr-button" onclick="showQRCode()">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
            <path d="M0 0h6v6H0V0zm2 2v2h2V2H2zm8-2h6v6h-6V0zm2 2v2h2V2h-2zM0 10h6v6H0v-6zm2 2v2h2v-2H2zm8-2h2v2h-2v-2zm2 2h2v2h-2v-2zm-2 2h2v2h-2v-2z"/>
        </svg>
        QR Code
    </button>
</div>
<div class="speaker-indicator" id="speaker-indicator">
    🎤 Speaker Mode Active
    <button onclick="copySpeakerLink()" title="Copy speaker link to share">Copy Link</button>
    <button onclick="exitSpeakerMode()" title="Exit speaker mode">Exit</button>
</div>
<div class="session-warning" id="session-warning"></div>
<div class="session-controls" id="session-controls">
    <h2 class="session-controls-title">Session Setup</h2>
    <p class="session-controls-description">Create a fresh session or join an existing one.</p>
    <button id="create-session-btn" type="button">Create New Session</button>
    <div class="session-links" id="session-links">
        <div class="session-link-row">
            <label for="audience-link">Audience</label>
            <input id="audience-link" type="text" readonly>
            <button id="copy-audience-link" type="button">Copy</button>
        </div>
        <div class="session-link-row">
            <label for="speaker-link">Speaker</label>
            <input id="speaker-link" type="text" readonly>
            <button id="copy-speaker-link" type="button">Copy</button>
        </div>
        <p style="font-size: 0.8rem; color: var(--text-secondary); text-align: center;">Share the speaker link privately—anyone with it can manage questions.</p>
    </div>
    <div class="manual-session">
        <label for="manual-session-input">Have a session ID?</label>
        <div class="manual-session-row">
            <input id="manual-session-input" type="text" placeholder="Enter session ID">
            <button id="manual-session-join-btn" type="button">Join</button>
        </div>
    </div>
</div>
<a href="#qa-form" class="mobile-ask-btn">✨ Ask a Question</a>
</header>

<main class="qa-list-container">
<div class="qa-list" id="qa-list">
    <div class="loading-state" id="loading-state">Loading questions...</div>
</div>
</main>

<aside class="side-panel">
<div class="form-container">
    <h2 id="form-title">Ask a Question</h2>
    <form id="qa-form">
        <div class="form-group">
            <label for="question-input">Your Question</label>
            <textarea id="question-input" rows="4" required></textarea>
        </div>
        <div class="form-group">
            <label for="author-input">Your Name (Optional)</label>
            <input type="text" id="author-input">
        </div>
        <button type="submit" class="submit-btn" id="submit-btn">Submit</button>
    </form>
</div>
</aside>
</div>

<!-- Template for Q&A card -->
<template id="qa-card-template">
<section class="qa-card" data-question-id="">
<div class="vote-section">
    <button class="vote-btn question-upvote-btn" title="Upvote Question">▲</button>
    <span class="vote-count question-vote-count">0</span>
</div>
<div class="content-section">
    <div class="question-header">
        <span class="author-name"></span>
        <span class="timestamp"></span>
        <span class="status-badge"></span>
    </div>
    <p class="question-text"></p>
    <div class="ai-answer-container" style="display: none;">
        <div class="ai-answer-header">
            <span class="ai-title">AI Assistant</span>
            <div class="ai-vote-controls">
                <button class="ai-vote-btn up-vote" title="Good Answer">👍</button>
                <span class="ai-vote-count up-vote-count">0</span>
                <button class="ai-vote-btn down-vote" title="Bad Answer">👎</button>
                <span class="ai-vote-count down-vote-count">0</span>
            </div>
        </div>
        <div class="ai-answer-text"></div>
    </div>
    <div class="speaker-actions" style="display: none;">
        <button class="speaker-btn mark-answered-btn">Mark as Answered Live</button>
        <button class="speaker-btn secondary mark-ai-correct-btn">Mark AI as Correct</button>
        <button class="speaker-btn secondary hide-ai-btn">Hide AI Answer</button>
        <button class="speaker-btn danger hide-question-btn">Hide Question</button>
    </div>
</div>
</section>
</template>

<!-- QR Code Modal -->
<div class="qr-modal" id="qrModal" onclick="closeQRModal(event)">
<div class="qr-modal-content" onclick="event.stopPropagation()">
<h2>Scan to Join Q&A Session</h2>
<p>Share this QR code with your audience</p>
<div id="qrcode"></div>
<div class="qr-url" id="qrUrl"></div>
<button class="close-qr" onclick="closeQRModal()">Close</button>
</div>
</div>

<script>
// --- CONFIGURATION ---
const WORKER_URL = 'https://q-and-a-app.audd.workers.dev';
const POLLING_INTERVAL_MS = 3000; // 3 seconds
// ---------------------

let toastContainer = null;

function getToastContainer() {
    if (!toastContainer) {
        toastContainer = document.getElementById('toast-container');
    }
    return toastContainer;
}

function hideToast(toast) {
    if (!toast) return;
    toast.classList.remove('show');
    toast.addEventListener('transitionend', () => toast.remove(), { once: true });
}

function showToast(message, options = {}) {
    const container = getToastContainer();
    if (!container) return;

    const { type = 'info', duration = 4000 } = options;
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;

    const text = document.createElement('span');
    text.textContent = message;
    toast.appendChild(text);

    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'toast-close';
    closeBtn.setAttribute('aria-label', 'Dismiss notification');
    closeBtn.textContent = '×';
    closeBtn.addEventListener('click', () => hideToast(toast));
    toast.appendChild(closeBtn);

    container.appendChild(toast);

    requestAnimationFrame(() => { toast.classList.add('show'); });

    if (duration !== null) {
        setTimeout(() => hideToast(toast), duration);
    }
}

function showDialog({ message, confirmText = 'OK', cancelText, copyValue, type = 'info' } = {}) {
    return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = `modal-overlay modal-${type}`;

        const dialog = document.createElement('div');
        dialog.className = 'modal-dialog';
        dialog.setAttribute('role', 'dialog');
        dialog.setAttribute('aria-modal', 'true');
        overlay.appendChild(dialog);

        const messageEl = document.createElement('p');
        messageEl.textContent = message;
        dialog.appendChild(messageEl);

        let copyInput = null;
        if (copyValue) {
            const copyField = document.createElement('div');
            copyField.className = 'modal-copy-field';

            copyInput = document.createElement('input');
            copyInput.type = 'text';
            copyInput.value = copyValue;
            copyInput.readOnly = true;
            copyInput.setAttribute('aria-label', 'Value to copy');
            copyField.appendChild(copyInput);

            const copyButton = document.createElement('button');
            copyButton.type = 'button';
            copyButton.textContent = 'Copy';
            copyButton.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(copyValue);
                    showToast('Copied to clipboard.', { type: 'success', duration: 2500 });
                } catch {
                    copyInput.select();
                    const fallbackResult = document.execCommand ? document.execCommand('copy') : false;
                    if (fallbackResult) {
                        showToast('Copied to clipboard.', { type: 'success', duration: 2500 });
                    } else {
                        showToast('Use Ctrl+C (or Command+C) to copy the selected text.', { type: 'info', duration: 5000 });
                    }
                }
            });
            copyField.appendChild(copyButton);
            dialog.appendChild(copyField);

            setTimeout(() => copyInput?.select(), 75);
        }

        const actions = document.createElement('div');
        actions.className = 'modal-actions';
        dialog.appendChild(actions);

        const cleanup = (result) => {
            document.removeEventListener('keydown', handleKeydown);
            overlay.remove();
            resolve(result);
        };

        if (cancelText) {
            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.textContent = cancelText;
            cancelBtn.addEventListener('click', () => cleanup(false));
            actions.appendChild(cancelBtn);
        }

        const confirmBtn = document.createElement('button');
        confirmBtn.type = 'button';
        confirmBtn.className = 'modal-confirm';
        confirmBtn.textContent = confirmText;
        confirmBtn.addEventListener('click', () => cleanup(true));
        actions.appendChild(confirmBtn);

        const handleKeydown = (event) => {
            if (event.key === 'Escape') {
                if (cancelText) {
                    event.preventDefault();
                    cleanup(false);
                }
            } else if (event.key === 'Enter' && document.activeElement === confirmBtn) {
                event.preventDefault();
                cleanup(true);
            }
        };

        overlay.addEventListener('click', (event) => {
            if (event.target === overlay && cancelText) {
                cleanup(false);
            }
        });

        document.addEventListener('keydown', handleKeydown);
        document.body.appendChild(overlay);
        (copyInput || confirmBtn).focus();
    });
}

// Global functions for speaker mode and QR code
async function exitSpeakerMode() {
const params = new URLSearchParams(window.location.search);
const currentSession = params.get('session');

const confirmed = await showDialog({
    message: 'Are you sure you want to exit speaker mode? You will need the speaker key to re-enter.',
    confirmText: 'Exit Speaker Mode',
    cancelText: 'Stay in Speaker Mode',
    type: 'warning'
});

if (!confirmed) return;

if (currentSession) {
    localStorage.removeItem(`qa_speaker_key_${currentSession}`);
}
localStorage.removeItem('qa_speaker_key'); // legacy cleanup
location.reload();
}

async function copySpeakerLink() {
const params = new URLSearchParams(window.location.search);
const sessionId = params.get('session') || '';
if (!sessionId) {
    showToast('A session ID is required before you can copy a speaker link.', { type: 'warning' });
    return;
}

const storageKey = `qa_speaker_key_${sessionId}`;
const speakerKey = localStorage.getItem(storageKey) || localStorage.getItem('qa_speaker_key');

if (!speakerKey) {
    showToast('No speaker key found for this session. Use a link that includes the speaker key.', { type: 'warning' });
    return;
}

const speakerUrl = `${window.location.origin}${window.location.pathname}?session=${sessionId}&speaker_key=${speakerKey}`;

try {
    await navigator.clipboard.writeText(speakerUrl);
    showToast('Speaker link copied to clipboard! Share this link privately to give someone speaker access.', { type: 'success' });
} catch {
    showToast('Automatic copy failed. Copy the speaker link manually.', { type: 'warning', duration: 5000 });
    await showDialog({
        message: 'Copy this speaker link manually:',
        confirmText: 'Done',
        copyValue: speakerUrl,
        type: 'info'
    });
}
}

function showQRCode() {
const params = new URLSearchParams(window.location.search);
const sessionId = params.get('session') || '';
if (!sessionId) {
    showToast('A session ID is required before generating a QR code.', { type: 'warning' });
    return;
}
const sessionUrl = `${window.location.origin}${window.location.pathname}?session=${sessionId}`;

// Clear previous QR code if any
document.getElementById('qrcode').innerHTML = '';

// Generate QR code
new QRCode(document.getElementById('qrcode'), {
    text: sessionUrl,
    width: 256,
    height: 256,
    colorDark: '#000000',
    colorLight: '#ffffff',
    correctLevel: QRCode.CorrectLevel.H
});

// Show URL
document.getElementById('qrUrl').textContent = sessionUrl;

// Show modal
document.getElementById('qrModal').classList.add('show');
}

function closeQRModal(event) {
if (!event || event.target === document.getElementById('qrModal')) {
    document.getElementById('qrModal').classList.remove('show');
}
}

function enhanceAiAnswerLinks(container) {
    if (!container) return;
    container.querySelectorAll('a').forEach((anchor) => {
        anchor.setAttribute('target', '_blank');
        const existingRel = anchor.getAttribute('rel') || '';
        const relTokens = new Set(existingRel.split(/\s+/).filter(Boolean));
        relTokens.add('noopener');
        relTokens.add('noreferrer');
        anchor.setAttribute('rel', Array.from(relTokens).join(' '));
    });
}

document.addEventListener('DOMContentLoaded', () => {
if (WORKER_URL.includes('your-username')) {
    showDialog({
        message: 'CRITICAL: Please update the WORKER_URL in the script tag!',
        confirmText: 'Close',
        type: 'error'
    });
    return;
}

const qaList = document.getElementById('qa-list');
const cardTemplate = document.getElementById('qa-card-template');
const sessionWarning = document.getElementById('session-warning');
const formElement = document.getElementById('qa-form');
const submitButton = document.getElementById('submit-btn');
const questionInputField = document.getElementById('question-input');
const authorInputField = document.getElementById('author-input');
const formTitle = document.getElementById('form-title');
const formContainer = document.querySelector('.form-container');
const baseAppUrl = `${window.location.origin}${window.location.pathname}`;
const createSessionButton = document.getElementById('create-session-btn');
const sessionControlsContainer = document.getElementById('session-controls');
const sessionLinksContainer = document.getElementById('session-links');
const audienceLinkInput = document.getElementById('audience-link');
const speakerLinkInput = document.getElementById('speaker-link');
const copyAudienceButton = document.getElementById('copy-audience-link');
const copySpeakerButton = document.getElementById('copy-speaker-link');
const manualSessionInput = document.getElementById('manual-session-input');
const manualSessionJoinButton = document.getElementById('manual-session-join-btn');

const sessionToolsButton = Array.from(document.querySelectorAll('button')).find(
    (button) => button.textContent && button.textContent.trim().toLowerCase() === 'session tools'
);
if (sessionToolsButton) {
    const label = document.createElement('span');
    label.className = 'session-tools-label';
    label.textContent = sessionToolsButton.textContent.trim();
    sessionToolsButton.replaceWith(label);
}

let sessionId = '';
let speakerKey = '';
let speakerStorageKey = '';
let questions = new Map();
let votedItems = { questions: [], answers: [] };
let pollingTimerId = null;
let sessionUnavailable = false;

const getVotedItems = () => {
    try {
        const stored = localStorage.getItem(`votedItems_${sessionId}`);
        return stored ? JSON.parse(stored) : { questions: [], answers: [] };
    } catch { return { questions: [], answers: [] }; }
};
const saveVotedItems = () => localStorage.setItem(`votedItems_${sessionId}`, JSON.stringify(votedItems));

// Fixed voting functions - map singular to plural
const hasVoted = (type, id) => {
    const storageType = type === 'question' ? 'questions' : 'answers';
    return votedItems[storageType].includes(id);
};
const addVote = (type, id) => {
    const storageType = type === 'question' ? 'questions' : 'answers';
    if (!votedItems[storageType].includes(id)) {
        votedItems[storageType].push(id);
        saveVotedItems();
    }
};

const setFormEnabled = (enabled, options = {}) => {
    const reason = options.reason || 'default';
    const disableOverlay = !enabled && reason === 'initial';

    [questionInputField, authorInputField, submitButton].forEach((el) => {
        if (el) el.disabled = !enabled;
    });

    if (formTitle) {
        formTitle.textContent = enabled ? 'Ask a Question' : disableOverlay ? 'Ask a Question' : 'Session unavailable';
    }

    if (submitButton) {
        submitButton.textContent = enabled ? 'Submit' : disableOverlay ? 'Submit' : 'Session Required';
    }

    if (questionInputField) {
        questionInputField.placeholder = enabled
            ? 'Type your question here'
            : disableOverlay ? 'Type your question here' : 'Create or join a session to ask questions';
    }

    if (formContainer) {
        formContainer.classList.toggle('disabled', !enabled && !disableOverlay);
    }
};

const displaySessionWarning = (messageHtml) => {
    if (!sessionWarning) return;
    sessionWarning.innerHTML = messageHtml;
    sessionWarning.style.display = 'block';
};

const clearSessionWarning = () => {
    if (!sessionWarning) return;
    sessionWarning.style.display = 'none';
    sessionWarning.innerHTML = '';
};

const stopPolling = () => {
    if (pollingTimerId) {
        clearInterval(pollingTimerId);
        pollingTimerId = null;
    }
};

const startPolling = () => {
    stopPolling();
    pollingTimerId = setInterval(fetchAndRefresh, POLLING_INTERVAL_MS);
};

const copyToClipboard = async (value, description) => {
    if (!value) return false;
    const label = description ?? 'value';
    try {
        await navigator.clipboard.writeText(value);
        showToast(`${label} copied to clipboard.`, { type: 'success' });
        return true;
    } catch {
        showToast(`Automatic copy failed. Copy the ${label.toLowerCase()} manually.`, { type: 'warning', duration: 5000 });
        await showDialog({
            message: `Copy this ${label.toLowerCase()} manually:`,
            confirmText: 'Done',
            copyValue: value,
            type: 'info'
        });
        return false;
    }
};

const updateSessionLinks = (audienceUrl, speakerUrl) => {
    if (!sessionLinksContainer) return;
    if (audienceLinkInput) audienceLinkInput.value = audienceUrl;
    if (speakerLinkInput) speakerLinkInput.value = speakerUrl;
    sessionLinksContainer.style.display = 'flex';
};

const clearSessionLinks = () => {
    if (sessionLinksContainer) sessionLinksContainer.style.display = 'none';
    if (audienceLinkInput) audienceLinkInput.value = '';
    if (speakerLinkInput) speakerLinkInput.value = '';
};

const handleSessionMissing = (reason) => {
    const isInitial = reason === 'missing';

    if (isInitial) {
        clearSessionWarning();
    } else {
        displaySessionWarning(`We couldn't find this session. It might have expired or was never created. Try entering a different session ID or create a new session above.`);
    }

    qaList.innerHTML = isInitial
        ? '<div class="empty-state">Create or join a session to see questions here.</div>'
        : '<div class="empty-state">Session unavailable.</div>';

    setFormEnabled(false, { reason: isInitial ? 'initial' : 'error' });
    sessionUnavailable = true;
    speakerKey = '';
    speakerStorageKey = '';
    document.body.classList.remove('speaker-view');
    document.body.classList.remove('session-active');
    document.body.classList.add('session-unavailable');
    questions.clear();
    clearSessionLinks();

    if (sessionControlsContainer) {
        sessionControlsContainer.style.display = 'flex';
    }

    if (manualSessionInput) manualSessionInput.value = '';
    stopPolling();
};

const switchSession = (newSessionId, incomingSpeakerKey = '') => {
    if (!newSessionId) {
        document.getElementById('session-id-display').textContent = '—';
        handleSessionMissing('missing');
        return;
    }

    stopPolling();

    sessionId = newSessionId;
    speakerStorageKey = `qa_speaker_key_${sessionId}`;

    if (incomingSpeakerKey) {
        speakerKey = incomingSpeakerKey;
        localStorage.setItem(speakerStorageKey, speakerKey);
        localStorage.removeItem('qa_speaker_key');
    } else {
        speakerKey = localStorage.getItem(speakerStorageKey) || '';
        if (!speakerKey) {
            const legacyKey = localStorage.getItem('qa_speaker_key');
            if (legacyKey) {
                localStorage.setItem(speakerStorageKey, legacyKey);
                localStorage.removeItem('qa_speaker_key');
                speakerKey = legacyKey;
            }
        }
    }

    document.getElementById('session-id-display').textContent = sessionId;
    document.body.classList.toggle('speaker-view', Boolean(speakerKey));
    document.body.classList.remove('session-unavailable');
    document.body.classList.add('session-active');

    if (!speakerKey) {
        clearSessionLinks();
    }

    questions.clear();
    qaList.innerHTML = '<div class="loading-state" id="loading-state">Loading questions...</div>';

    votedItems = getVotedItems();
    clearSessionWarning();
    setFormEnabled(true);
    sessionUnavailable = false;
    if (sessionControlsContainer) {
        sessionControlsContainer.style.display = 'flex';
    }
    if (manualSessionInput) manualSessionInput.value = sessionId;

    const newUrl = `?session=${encodeURIComponent(sessionId)}`;
    if (window.location.search !== newUrl) {
        window.history.replaceState({}, '', newUrl);
    }

    fetchAndRefresh();
    startPolling();
};

const createSessionFromUi = async () => {
    if (!createSessionButton) return;
    const originalText = createSessionButton.textContent;
    createSessionButton.disabled = true;
    createSessionButton.textContent = 'Creating...';

    try {
        const response = await fetch(`${WORKER_URL}/api/sessions`, { method: 'POST' });
        if (!response.ok) throw new Error(`Create session failed with status ${response.status}`);

        const payload = await response.json();
        const newSessionId = payload?.sessionId;
        const newSpeakerKey = payload?.speakerKey;

        if (!newSessionId || !newSpeakerKey) {
            throw new Error('Session API returned an unexpected response.');
        }

        const audienceUrl = `${baseAppUrl}?session=${newSessionId}`;
        const speakerUrl = `${baseAppUrl}?session=${newSessionId}&speaker_key=${newSpeakerKey}`;

        updateSessionLinks(audienceUrl, speakerUrl);
        switchSession(newSessionId, newSpeakerKey);
        if (sessionControlsContainer) {
            sessionControlsContainer.style.display = 'flex';
        }
    } catch (error) {
        console.error('Create session failed:', error);
        showToast('Failed to create a new session. Please try again.', { type: 'error' });
    } finally {
        createSessionButton.disabled = false;
        createSessionButton.textContent = originalText;
    }
};

const joinSessionFromInput = () => {
    if (!manualSessionInput) return;
    const enteredId = manualSessionInput.value.trim();
    if (!enteredId) return;

    const normalizedId = enteredId.toLowerCase();
    manualSessionInput.value = normalizedId;
    switchSession(normalizedId);
};

function formatTimeAgo(dateString) {
    const seconds = Math.floor((new Date() - new Date(dateString)) / 1000);
    if (seconds < 60) return "Just now";
    const intervals = { y: 31536000, mo: 2592000, d: 86400, h: 3600, m: 60 };
    for (const [unit, value] of Object.entries(intervals)) {
        const interval = seconds / value;
        if (interval >= 1) return `${Math.floor(interval)}${unit} ago`;
    }
}

function updateCard(card, question) {
    // Update basic info
    card.querySelector('.question-vote-count').textContent = question.question_upvotes;
    card.querySelector('.author-name').textContent = question.author_name || 'Anonymous';
    card.querySelector('.timestamp').textContent = formatTimeAgo(question.created_at);
    card.querySelector('.question-text').textContent = question.question_text;
    
    // Update Status Badge
    const statusBadge = card.querySelector('.status-badge');
    statusBadge.className = 'status-badge';
    statusBadge.classList.add(question.status);
    if (question.hidden) statusBadge.classList.add('hidden');
    statusBadge.textContent = question.hidden ? 'hidden' : question.status.replace(/_/g, ' ');

    // Handle AI answer visibility
    const aiContainer = card.querySelector('.ai-answer-container');
    const aiTextElement = card.querySelector('.ai-answer-text');
    const shouldShowAi = question.ai_answer && !question.ai_answer_hidden;
    
    if (shouldShowAi || question.status === 'ai_answering') {
        aiContainer.style.display = 'block';
        
        if (question.ai_answer) {
            aiTextElement.innerHTML = marked.parse(question.ai_answer);
            enhanceAiAnswerLinks(aiTextElement);
            card.querySelector('.up-vote-count').textContent = question.ai_answer_upvotes;
            card.querySelector('.down-vote-count').textContent = question.ai_answer_downvotes;
            
            // Update AI title for marked correct
            const aiTitle = card.querySelector('.ai-title');
            aiTitle.classList.toggle('marked-correct', question.ai_answer_marked_correct);
            aiTitle.textContent = question.ai_answer_marked_correct ? 'AI Assistant (Correct)' : 'AI Assistant';
        } else if (question.status === 'ai_answering') {
            aiTextElement.innerHTML = '<em>Thinking...</em>';
        }
    } else {
        aiContainer.style.display = 'none';
    }

    // Speaker view logic
    const speakerActions = card.querySelector('.speaker-actions');
    if (speakerKey && question.status !== 'speaker_answered') {
        speakerActions.style.display = 'flex';
        
        // Update button texts based on states
        const hideQuestionBtn = card.querySelector('.hide-question-btn');
        hideQuestionBtn.textContent = question.hidden ? 'Show Question' : 'Hide Question';
        
        const hideAiBtn = card.querySelector('.hide-ai-btn');
        hideAiBtn.textContent = question.ai_answer_hidden ? 'Show AI Answer' : 'Hide AI Answer';
        hideAiBtn.style.display = question.ai_answer ? 'block' : 'none';
        
        const markAiBtn = card.querySelector('.mark-ai-correct-btn');
        markAiBtn.textContent = question.ai_answer_marked_correct ? 'Unmark AI as Correct' : 'Mark AI as Correct';
        markAiBtn.style.display = question.ai_answer ? 'block' : 'none';
    } else {
        speakerActions.style.display = 'none';
    }

    card.classList.toggle('answered-by-speaker', question.status === 'speaker_answered');
    card.classList.toggle('hidden', question.hidden);
    
    // Update voted states
    card.querySelector('.question-upvote-btn').classList.toggle('voted', hasVoted('question', question.id));
    card.querySelector('.ai-vote-btn.up-vote').classList.toggle('voted', hasVoted('answer', `${question.id}-up`));
    card.querySelector('.ai-vote-btn.down-vote').classList.toggle('voted', hasVoted('answer', `${question.id}-down`));
}

function sortCards() {
    const cards = Array.from(qaList.querySelectorAll('.qa-card'));
    cards.sort((a, b) => {
        const qA = questions.get(parseInt(a.dataset.questionId));
        const qB = questions.get(parseInt(b.dataset.questionId));
        
        // First sort by speaker_answered status
        if (qA.status === 'speaker_answered' && qB.status !== 'speaker_answered') return 1;
        if (qA.status !== 'speaker_answered' && qB.status === 'speaker_answered') return -1;
        
        // Then by upvotes
        if (qB.question_upvotes !== qA.question_upvotes) {
            return qB.question_upvotes - qA.question_upvotes;
        }
        
        // Finally by date (newer first)
        return new Date(qB.created_at) - new Date(qA.created_at);
    });
    cards.forEach(card => qaList.appendChild(card));
}

async function fetchAndRefresh() {
    if (!sessionId || sessionUnavailable) return;

    try {
        const url = speakerKey 
            ? `${WORKER_URL}/api/${sessionId}/questions?speaker_key=${speakerKey}`
            : `${WORKER_URL}/api/${sessionId}/questions`;

        const response = await fetch(url);
        if (response.status === 404) {
            handleSessionMissing('not-found');
            return;
        }
        if (!response.ok) return;

        const newQuestions = await response.json();
        if (!sessionUnavailable) {
            clearSessionWarning();
            setFormEnabled(true);
        }
        sessionUnavailable = false;

        const newQuestionIds = new Set(newQuestions.map(q => q.id));
        const currentQuestionIds = new Set(Array.from(questions.keys()));

        // Remove cards that are no longer present
        for(const id of currentQuestionIds) {
            if(!newQuestionIds.has(id)) {
                const cardToRemove = qaList.querySelector(`.qa-card[data-question-id='${id}']`);
                if(cardToRemove) cardToRemove.remove();
                questions.delete(id);
            }
        }

        if (newQuestions.length === 0 && questions.size === 0) {
            qaList.innerHTML = '<div class="empty-state">No questions yet. Be the first to ask!</div>';
            return;
        } else if (qaList.querySelector('.empty-state, .loading-state')) {
            qaList.innerHTML = '';
        }

        // Add or update cards
        newQuestions.forEach(q => {
            let card = qaList.querySelector(`.qa-card[data-question-id='${q.id}']`);
            if (!card) {
                card = cardTemplate.content.cloneNode(true).firstElementChild;
                card.dataset.questionId = q.id;
                card.classList.add('new-card');
                qaList.appendChild(card);
                requestAnimationFrame(() => card.classList.remove('new-card'));
            }
            updateCard(card, q);
            questions.set(q.id, q);
        });

        sortCards();
    } catch (error) {
        console.error('Polling failed:', error);
    }
}

// --- EVENT LISTENERS ---

if (createSessionButton) {
    createSessionButton.addEventListener('click', createSessionFromUi);
}

if (copyAudienceButton) {
    copyAudienceButton.addEventListener('click', async () => {
        if (!audienceLinkInput || !audienceLinkInput.value) {
            showToast('Audience link is not available yet.', { type: 'warning' });
            return;
        }
        await copyToClipboard(audienceLinkInput.value, 'Audience link');
    });
}

if (copySpeakerButton) {
    copySpeakerButton.addEventListener('click', async () => {
        if (!speakerLinkInput || !speakerLinkInput.value) {
            showToast('Speaker link is not available yet.', { type: 'warning' });
            return;
        }
        await copyToClipboard(speakerLinkInput.value, 'Speaker link');
    });
}

if (manualSessionJoinButton) {
    manualSessionJoinButton.addEventListener('click', joinSessionFromInput);
}

if (manualSessionInput) {
    manualSessionInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
            event.preventDefault();
            joinSessionFromInput();
        }
    });
}

formElement.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!sessionId || sessionUnavailable) {
        showToast('A valid session is required before submitting questions.', { type: 'warning' });
        return;
    }

    if (!questionInputField.value.trim()) {
        questionInputField.focus();
        return;
    }

    submitButton.disabled = true;
    submitButton.textContent = 'Submitting...';
    try {
        const response = await fetch(`${WORKER_URL}/api/${sessionId}/questions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                questionText: questionInputField.value,
                authorName: authorInputField.value,
            }),
        });

        if (response.status === 404) {
            handleSessionMissing('not-found');
            return;
        }
        if (!response.ok) return;

        questionInputField.value = '';
        await fetchAndRefresh();
    } catch (error) {
        console.error('Submit failed:', error);
    } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Submit';
    }
});

qaList.addEventListener('click', async (e) => {
    const card = e.target.closest('.qa-card');
    if (!card) return;
    const questionId = parseInt(card.dataset.questionId);
    
    const voteRequest = async (type, direction, voteId) => {
        if (hasVoted(type, voteId)) return;
        
        // Optimistic UI update
        addVote(type, voteId);
        e.target.classList.add('voted');
        const countEl = e.target.closest('.vote-section, .ai-vote-controls').querySelector(`.${direction}-vote-count, .question-vote-count`);
        if (countEl) countEl.textContent = parseInt(countEl.textContent) + 1;
        
        // Fire-and-forget request
        fetch(`${WORKER_URL}/api/questions/${questionId}/vote`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ type, direction })
        }).catch(err => console.error("Vote request failed:", err));
    };
    
    const speakerRequest = async (endpoint) => {
        if (!speakerKey) {
            showToast('Speaker key missing. Use a speaker link for this session.', { type: 'warning' });
            return;
        }
        e.target.disabled = true;
        const originalText = e.target.textContent;
        e.target.textContent = 'Processing...';
        
        try {
            const response = await fetch(`${WORKER_URL}/api/questions/${questionId}/${endpoint}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ speakerKey })
            });

            if (response.status === 403) {
                showToast('Speaker key is not valid for this session. Request a fresh speaker link.', { type: 'error' });
                if (speakerStorageKey) localStorage.removeItem(speakerStorageKey);
                speakerKey = '';
                document.body.classList.remove('speaker-view');
                qaList.querySelectorAll('.speaker-actions').forEach(section => { section.style.display = 'none'; });
                e.target.textContent = originalText;
                return;
            }

            if (!response.ok) {
                throw new Error(`Speaker action failed with status ${response.status}`);
            }
            await fetchAndRefresh(); // Immediate refresh after speaker action
        } catch (error) {
            console.error(`Speaker action ${endpoint} failed:`, error);
            showToast('Something went wrong while processing that speaker action.', { type: 'error' });
            e.target.textContent = originalText;
        } finally {
            e.target.disabled = false;
        }
    };
    
    // Handle all click events
    if (e.target.closest('.question-upvote-btn')) voteRequest('question', 'up', questionId);
    else if (e.target.closest('.ai-vote-btn.up-vote')) voteRequest('answer', 'up', `${questionId}-up`);
    else if (e.target.closest('.ai-vote-btn.down-vote')) voteRequest('answer', 'down', `${questionId}-down`);
    else if (e.target.closest('.mark-answered-btn')) speakerRequest('mark-answered');
    else if (e.target.closest('.hide-question-btn')) speakerRequest('toggle-hide');
    else if (e.target.closest('.mark-ai-correct-btn')) speakerRequest('mark-ai-correct');
    else if (e.target.closest('.hide-ai-btn')) speakerRequest('toggle-ai-hide');
});

// --- INITIALIZATION ---
function initializeApp() {
    const params = new URLSearchParams(window.location.search);
    const initialSession = params.get('session') || '';
    const urlSpeakerKey = params.get('speaker_key') || '';

    if (!initialSession) {
        document.getElementById('session-id-display').textContent = '—';
        handleSessionMissing('missing');
        return;
    }

    switchSession(initialSession, urlSpeakerKey);
}

// Handle mobile ask button click
document.querySelector('.mobile-ask-btn').addEventListener('click', (e) => {
    e.preventDefault();
    if (submitButton.disabled) {
        showToast('The session is not ready for questions yet. Create a session first.', { type: 'warning' });
        return;
    }
    const form = document.getElementById('qa-form');
    form.scrollIntoView({ behavior: 'smooth', block: 'center' });
    setTimeout(() => {
        document.getElementById('question-input').focus();
    }, 500);
});

// Handle Escape key to close QR modal
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeQRModal();
    }
});

initializeApp();
});
</script>
</body>
</html>
